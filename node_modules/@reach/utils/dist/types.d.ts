import * as React from "react";
import { Validator } from "prop-types";
export declare type AssignableRef<T = any> = React.Ref<T | null>;
/**
 * Type can be either a single `T` or an array of `T`
 */
export declare type SingleOrArray<T> = T[] | T;
/**
 * The built-in utility type `Omit` does not distribute over unions. So if you
 * have:
 *
 *    type A = { a: 'whatever' }
 *
 * and you want to do a union with:
 *
 *    type B = A & { b: number } | { b: string; c: number }
 *
 * you might expect `Omit<B, 'a'>` to give you:
 *
 *    Omit<{ a: 'whatever'; b: number }, 'a'> | Omit<{ a: 'whatever'; b: string; c: number }, 'a'>
 *
 * This is not the case, unfortunately, so we need to create our own version of
 * `Omit` that distributes over unions with a distributive conditional type. If
 * you have a generic type parameter `T`, then the construct
 * `T extends any ? F<T> : never` will end up distributing the `F<>` operation
 * over `T` when `T` is a union type.
 *
 * @link https://stackoverflow.com/a/59796484/1792019
 * @link http://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types
 */
export declare type DistributiveOmit<T, K extends PropertyKey> = T extends any ? Omit<T, K> : never;
export declare type As<P = any> = React.ElementType<P>;
export declare type PropsWithAs<T extends As, P> = P & Omit<React.ComponentPropsWithRef<T>, "as" | keyof P> & {
    as?: T;
};
export declare type PropsFromAs<T extends As, P> = (PropsWithAs<T, P> & {
    as: T;
}) & PropsWithAs<T, P>;
export declare type ComponentWithForwardedRef<T extends React.ElementType, P> = React.ForwardRefExoticComponent<P & React.HTMLProps<React.ElementType<T>> & React.ComponentPropsWithRef<T>>;
export interface ComponentWithAs<T extends As, P> {
    <TT extends As>(props: PropsWithAs<TT, P>): JSX.Element;
    (props: PropsWithAs<T, P>): JSX.Element;
    displayName?: string;
    propTypes?: {
        [key: string]: Validator<any>;
    };
}
