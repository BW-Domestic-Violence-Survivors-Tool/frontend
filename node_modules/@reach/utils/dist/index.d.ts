import React from "react";
import { As, AssignableRef, ComponentWithAs, ComponentWithForwardedRef, DistributiveOmit, PropsFromAs, PropsWithAs } from "./types";
/**
 * React currently throws a warning when using useLayoutEffect on the server.
 * To get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also
 * need affected components to render on the server. One example is when setting
 * a component's descendants to retrieve their index values.
 *
 * Important to note that using this hook as an escape hatch will break the
 * eslint dependency warnings unless you rename the import to `useLayoutEffect`.
 * Use sparingly only when the effect won't effect the rendered HTML to avoid
 * any server/client mismatch.
 *
 * If a useLayoutEffect is needed and the result would create a mismatch, it's
 * likely that the component in question shouldn't be rendered on the server at
 * all, so a better approach would be to lazily render those in a parent
 * component after client-side hydration.
 *
 * TODO: We are calling useLayoutEffect in a couple of places that will likely
 * cause some issues for SSR users, whether the warning shows or not. Audit and
 * fix these.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 *
 * @param effect
 * @param deps
 */
export declare const useIsomorphicLayoutEffect: typeof React.useLayoutEffect;
/**
 * When in dev mode, checks that styles for a given @reach package are loaded.
 *
 * @param packageName Name of the package to check.
 * @example checkStyles("dialog") will check for styles for @reach/dialog
 */
declare let checkStyles: (packageName: string) => void;
export { checkStyles };
/**
 * Passes or assigns an arbitrary value to a ref function or object.
 *
 * @param ref
 * @param value
 */
export declare function assignRef<T = any>(ref: AssignableRef<T> | undefined, value: any): void;
export declare function boolOrBoolString(value: any): boolean;
export declare function canUseDOM(): boolean;
export declare function cloneValidElement<P>(element: React.ReactElement<P> | React.ReactNode, props?: Partial<P> & React.Attributes, ...children: React.ReactNode[]): React.ReactElement<P> | React.ReactNode;
export declare function createNamedContext<T>(name: string, defaultValue: T): React.Context<T>;
export declare function findLastIndex<T = any>(array: T[], predicate: (element: T, index?: number, arr?: T[]) => boolean): number;
/**
 * Get the scrollbar offset distance.
 */
export declare function getScrollbarOffset(): number;
export declare function isUndefined(value: any): boolean;
/**
 * Joins strings to format IDs for compound components.
 *
 * @param args
 */
export declare function makeId(...args: (string | number | null | undefined)[]): string;
/**
 * No-op function.
 */
export declare function noop(): void;
export declare function useConstant<T>(fn: () => T): T;
/**
 * Passes or assigns a value to multiple refs (typically a DOM node). Useful for
 * dealing with components that need an explicit ref for DOM calculations but
 * also forwards refs assigned by an app.
 *
 * @param refs Refs to fork
 */
export declare function useForkedRef<T = any>(...refs: (AssignableRef<T> | undefined)[]): ((node: any) => void) | null;
/**
 * Returns the previous value of a reference after a component update.
 *
 * @param value
 */
export declare function usePrevious<T = any>(value: T): T | null;
/**
 * Call an effect after a component update, skipping the initial mount.
 *
 * @param effect Effect to call
 * @param deps Effect dependency list
 */
export declare function useUpdateEffect(effect: () => any, deps?: any[]): void;
/**
 * Wraps a lib-defined event handler and a user-defined event handler, returning
 * a single handler that allows a user to prevent lib-defined handlers from
 * firing.
 *
 * @param theirHandler User-supplied event handler
 * @param ourHandler Library-supplied event handler
 */
export declare function wrapEvent<E extends React.SyntheticEvent | Event>(theirHandler: ((event: E) => any) | undefined, ourHandler: (event: E) => any): (event: E) => any;
/**
 * This is a hack for sure. The thing is, getting a component to intelligently
 * infer props based on a component or JSX string passed into an `as` prop is
 * kind of a huge pain. Getting it to work and satisfy the constraints of
 * `forwardRef` seems dang near impossible. To avoid needing to do this awkward
 * type song-and-dance every time we want to forward a ref into a component
 * that accepts an `as` prop, we abstract all of that mess to this function for
 * the time time being.
 *
 * TODO: Eventually we should probably just try to get the type defs above
 * working across the board, but ain't nobody got time for that mess!
 *
 * @param Comp
 */
export declare function forwardRefWithAs<P, T extends As>(comp: (props: PropsFromAs<T, P>, ref: React.RefObject<any>) => JSX.Element): ComponentWithAs<T, P>;
export { As, AssignableRef, ComponentWithAs, ComponentWithForwardedRef, DistributiveOmit, PropsFromAs, PropsWithAs };
export declare type Descendant<T, P = {}> = P & {
    element: (T extends HTMLElement ? T : HTMLElement) | null;
    index: number;
};
export interface IDescendantContext<T, P> {
    descendants: Descendant<T, P>[];
    registerDescendant(descendant: Descendant<T, P>): void;
    unregisterDescendant(element: (T extends HTMLElement ? T : HTMLElement) | null): void;
}
export declare function createDescendantContext<T, P = {}>(name: string, initialValue?: {}): React.Context<IDescendantContext<T, P>>;
/**
 * This hook registers our descendant by passing it into an array. We can then
 * search that array by to find its index when registering it in the component.
 * We use this for focus management, keyboard navigation, and typeahead
 * functionality for some components.
 *
 * The hook accepts the element node and (optionally) a key. The key is useful
 * if multiple descendants have identical text values and we need to
 * differentiate siblings for some reason.
 *
 * Our main goals with this are:
 *   1) maximum composability,
 *   2) minimal API friction
 *   3) SSR compatibility*
 *   4) concurrent safe
 *   5) index always up-to-date with the tree despite changes
 *   6) works with memoization of any component in the tree (hopefully)
 *
 * * As for SSR, the good news is that we don't actually need the index on the
 * server for most use-cases, as we are only using it to determine the order of
 * composed descendants for keyboard navigation. However, in the few cases where
 * this is not the case, we can require an explicit index from the app.
 */
export declare function useDescendant<T, P>({ context, element, ...rest }: Omit<Descendant<T, P>, "index"> & {
    context: React.Context<IDescendantContext<T, P>>;
}, indexProp?: number): number;
export declare function useDescendants<T, P = {}>(): [Descendant<T, P>[], React.Dispatch<React.SetStateAction<Descendant<T, P>[]>>];
export declare function DescendantProvider<T, P>({ context: Ctx, children, items, set }: {
    context: React.Context<IDescendantContext<T, P>>;
    children: React.ReactNode;
    items: Descendant<T, P>[];
    set: React.Dispatch<React.SetStateAction<Descendant<T, P>[]>>;
}): JSX.Element;
