'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * React currently throws a warning when using useLayoutEffect on the server.
 * To get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also
 * need affected components to render on the server. One example is when setting
 * a component's descendants to retrieve their index values.
 *
 * Important to note that using this hook as an escape hatch will break the
 * eslint dependency warnings unless you rename the import to `useLayoutEffect`.
 * Use sparingly only when the effect won't effect the rendered HTML to avoid
 * any server/client mismatch.
 *
 * If a useLayoutEffect is needed and the result would create a mismatch, it's
 * likely that the component in question shouldn't be rendered on the server at
 * all, so a better approach would be to lazily render those in a parent
 * component after client-side hydration.
 *
 * TODO: We are calling useLayoutEffect in a couple of places that will likely
 * cause some issues for SSR users, whether the warning shows or not. Audit and
 * fix these.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 *
 * @param effect
 * @param deps
 */

var useIsomorphicLayoutEffect =
/*#__PURE__*/
canUseDOM() ? React__default.useLayoutEffect : React__default.useEffect;
var useLayoutEffect = useIsomorphicLayoutEffect;
var checkedPkgs = {};
/**
 * When in dev mode, checks that styles for a given @reach package are loaded.
 *
 * @param packageName Name of the package to check.
 * @example checkStyles("dialog") will check for styles for @reach/dialog
 */
// @ts-ignore

exports.checkStyles = function checkStyles(packageName) {};

{
  exports.checkStyles = function checkStyles(pkg) {
    // only check once per package
    if (checkedPkgs[pkg]) return;
    checkedPkgs[pkg] = true;

    if ( parseInt(window.getComputedStyle(document.body).getPropertyValue("--reach-" + pkg), 10) !== 1) {
      console.warn("@reach/" + pkg + " styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\n\n    import \"@reach/" + pkg + "/styles.css\";\n\n  Otherwise you'll need to include them some other way:\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"node_modules/@reach/" + pkg + "/styles.css\" />\n\n  For more information visit https://ui.reach.tech/styling.\n  ");
    }
  };
}
/**
 * Passes or assigns an arbitrary value to a ref function or object.
 *
 * @param ref
 * @param value
 */

function assignRef(ref, value) {
  if (ref == null) return;

  if (typeof ref === "function") {
    ref(value);
  } else {
    try {
      // @ts-ignore
      ref.current = value;
    } catch (error) {
      throw new Error("Cannot assign value \"" + value + "\" to ref \"" + ref + "\"");
    }
  }
}
function boolOrBoolString(value) {
  return value === "false" ? false : Boolean(value);
}
function canUseDOM() {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
}
function cloneValidElement(element, props) {
  if (!React.isValidElement(element)) {
    return element;
  }

  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  return React.cloneElement.apply(void 0, [element, props].concat(children));
}
function createNamedContext(name, defaultValue) {
  var Ctx = React.createContext(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}
function findLastIndex(array, predicate) {
  var length = array.length >>> 0;

  if (!length) {
    return -1;
  }

  var n = length - 1;

  while (n >= 0) {
    var value = array[n];

    if (predicate(value, n, array)) {
      return n;
    }

    --n;
  }

  return -1;
}
/**
 * Get the scrollbar offset distance.
 */

function getScrollbarOffset() {
  try {
    if (window.innerWidth > document.documentElement.clientWidth) {
      return window.innerWidth - document.documentElement.clientWidth;
    }
  } catch (err) {}

  return 0;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
/**
 * Joins strings to format IDs for compound components.
 *
 * @param args
 */

function makeId() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.filter(function (val) {
    return val != null;
  }).join("--");
}
/**
 * No-op function.
 */

function noop() {} // React hook for creating a value exactly once.
// https://github.com/Andarist/use-constant

function useConstant(fn) {
  var ref = React__default.useRef();

  if (!ref.current) {
    ref.current = {
      v: fn()
    };
  }

  return ref.current.v;
}
/**
 * Passes or assigns a value to multiple refs (typically a DOM node). Useful for
 * dealing with components that need an explicit ref for DOM calculations but
 * also forwards refs assigned by an app.
 *
 * @param refs Refs to fork
 */

function useForkedRef() {
  for (var _len3 = arguments.length, refs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    refs[_key3] = arguments[_key3];
  }

  return React.useMemo(function () {
    if (refs.every(function (ref) {
      return ref == null;
    })) {
      return null;
    }

    return function (node) {
      refs.forEach(function (ref) {
        assignRef(ref, node);
      });
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, refs);
}
/**
 * Returns the previous value of a reference after a component update.
 *
 * @param value
 */

function usePrevious(value) {
  var ref = React.useRef(null);
  React.useEffect(function () {
    ref.current = value;
  }, [value]);
  return ref.current;
}
/**
 * Call an effect after a component update, skipping the initial mount.
 *
 * @param effect Effect to call
 * @param deps Effect dependency list
 */

function useUpdateEffect(effect, deps) {
  var mounted = React.useRef(false);
  React.useEffect(function () {
    if (mounted.current) {
      effect();
    } else {
      mounted.current = true;
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, deps);
}
/**
 * Wraps a lib-defined event handler and a user-defined event handler, returning
 * a single handler that allows a user to prevent lib-defined handlers from
 * firing.
 *
 * @param theirHandler User-supplied event handler
 * @param ourHandler Library-supplied event handler
 */

function wrapEvent(theirHandler, ourHandler) {
  return function (event) {
    theirHandler && theirHandler(event);

    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}
/**
 * This is a hack for sure. The thing is, getting a component to intelligently
 * infer props based on a component or JSX string passed into an `as` prop is
 * kind of a huge pain. Getting it to work and satisfy the constraints of
 * `forwardRef` seems dang near impossible. To avoid needing to do this awkward
 * type song-and-dance every time we want to forward a ref into a component
 * that accepts an `as` prop, we abstract all of that mess to this function for
 * the time time being.
 *
 * TODO: Eventually we should probably just try to get the type defs above
 * working across the board, but ain't nobody got time for that mess!
 *
 * @param Comp
 */

function forwardRefWithAs(comp) {
  return React__default.forwardRef(comp);
}
function createDescendantContext(name, initialValue) {
  if (initialValue === void 0) {
    initialValue = {};
  }

  return createNamedContext(name, _extends({
    descendants: [],
    registerDescendant: noop,
    unregisterDescendant: noop
  }, initialValue));
}
/**
 * This hook registers our descendant by passing it into an array. We can then
 * search that array by to find its index when registering it in the component.
 * We use this for focus management, keyboard navigation, and typeahead
 * functionality for some components.
 *
 * The hook accepts the element node and (optionally) a key. The key is useful
 * if multiple descendants have identical text values and we need to
 * differentiate siblings for some reason.
 *
 * Our main goals with this are:
 *   1) maximum composability,
 *   2) minimal API friction
 *   3) SSR compatibility*
 *   4) concurrent safe
 *   5) index always up-to-date with the tree despite changes
 *   6) works with memoization of any component in the tree (hopefully)
 *
 * * As for SSR, the good news is that we don't actually need the index on the
 * server for most use-cases, as we are only using it to determine the order of
 * composed descendants for keyboard navigation. However, in the few cases where
 * this is not the case, we can require an explicit index from the app.
 */

function useDescendant(_ref, indexProp) {
  var context = _ref.context,
      element = _ref.element,
      rest = _objectWithoutPropertiesLoose(_ref, ["context", "element"]);

  var _useState = React.useState(),
      forceUpdate = _useState[1];

  var _useContext = React.useContext(context),
      registerDescendant = _useContext.registerDescendant,
      unregisterDescendant = _useContext.unregisterDescendant,
      descendants = _useContext.descendants; // Prevent any flashing


  useLayoutEffect(function () {
    if (!element) forceUpdate({}); // @ts-ignore

    registerDescendant(_extends({
      element: element
    }, rest));
    return function () {
      return unregisterDescendant(element);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [element].concat(Object.values(rest)));
  return indexProp !== null && indexProp !== void 0 ? indexProp : descendants.findIndex(function (_ref2) {
    var _el = _ref2.element;
    return _el === element;
  });
}
function useDescendants() {
  return React.useState([]);
}
function DescendantProvider(_ref3) {
  var Ctx = _ref3.context,
      children = _ref3.children,
      items = _ref3.items,
      set = _ref3.set;
  var registerDescendant = React__default.useCallback(function (_ref4) {
    var element = _ref4.element,
        rest = _objectWithoutPropertiesLoose(_ref4, ["element"]);

    if (!element) {
      return;
    }

    set(function (items) {
      if (items.find(function (_ref5) {
        var _el = _ref5.element;
        return _el === element;
      }) == null) {
        /*
         * When registering a descendant, we need to make sure we insert in
         * into the array in the same order that it appears in the DOM. So as
         * new descendants are added or maybe some are removed, we always know
         * that the array is up-to-date and correct.
         *
         * So here we look at our registered descendants and see if the new
         * element we are adding appears earlier than an existing descendant's
         * DOM node via `node.compareDocumentPosition`. If it does, we insert
         * the new element at this index. Because `registerDescendant` will be
         * called in an effect every time the descendants state value changes,
         * we should be sure that this index is accurate when descendent
         * elements come or go from our component.
         */
        var index = items.findIndex(function (_ref6) {
          var existingElement = _ref6.element;

          if (!existingElement || !element) {
            return false;
          }
          /*
           * Does this element's DOM node appear before another item in the
           * array in our DOM tree? If so, return true to grab the index at
           * this point in the array so we know where to insert the new
           * element.
           */


          return Boolean(existingElement.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);
        });

        var newItem = _extends({
          element: element,
          index: index
        }, rest); // If an index is not found we will push the element to the end.


        if (index === -1) {
          return [].concat(items, [newItem]);
        }

        return [].concat(items.slice(0, index), [newItem], items.slice(index));
      }

      return items;
    });
  },
  /*
   * setDescendants is a state setter initialized by the useDescendants hook.
   * We can safely ignore the lint warning here because it will not change
   * between renders.
   */
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var unregisterDescendant = React.useCallback(function (element) {
    if (!element) {
      return;
    }

    set(function (items) {
      return items.filter(function (_ref7) {
        var _el = _ref7.element;
        return element !== _el;
      });
    });
  },
  /*
   * setDescendants is a state setter initialized by the useDescendants hook.
   * We can safely ignore the lint warning here because it will not change
   * between renders.
   */
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []); // Not sure about this just yet, may bail on this and let components deal

  /* let focusNodes = descendants
    .filter(({ disabled }) => !disabled)
    .map(({ element }) => element); */
  // @ts-ignore

  var value = React.useMemo(function () {
    return {
      descendants: items,
      registerDescendant: registerDescendant,
      unregisterDescendant: unregisterDescendant
    };
  }, [items, registerDescendant, unregisterDescendant]);
  return React__default.createElement(Ctx.Provider, {
    value: value
  }, children);
}

exports.DescendantProvider = DescendantProvider;
exports.assignRef = assignRef;
exports.boolOrBoolString = boolOrBoolString;
exports.canUseDOM = canUseDOM;
exports.cloneValidElement = cloneValidElement;
exports.createDescendantContext = createDescendantContext;
exports.createNamedContext = createNamedContext;
exports.findLastIndex = findLastIndex;
exports.forwardRefWithAs = forwardRefWithAs;
exports.getScrollbarOffset = getScrollbarOffset;
exports.isUndefined = isUndefined;
exports.makeId = makeId;
exports.noop = noop;
exports.useConstant = useConstant;
exports.useDescendant = useDescendant;
exports.useDescendants = useDescendants;
exports.useForkedRef = useForkedRef;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.usePrevious = usePrevious;
exports.useUpdateEffect = useUpdateEffect;
exports.wrapEvent = wrapEvent;
//# sourceMappingURL=utils.cjs.development.js.map
